<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Smart Exam Pro</title>
<link rel="icon" href="data:,">
<link rel="preconnect" href="https://unpkg.com">
<style>
  :root { --bg:#0b1220; --panel:#111a2b; --muted:#99a3b3; --text:#e9eef7; --brand:#6ae3ff; --accent:#8b5cf6; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;}
  .container{max-width:980px;margin:24px auto;padding:0 16px;}
  .header{display:flex;align-items:center;gap:10px;margin-bottom:16px}
  .dot{width:10px;height:10px;border-radius:50%;background:var(--brand);box-shadow:0 0 16px var(--brand)}
  h1{font-size:22px;margin:0}
  .card{background:var(--panel);border:1px solid #1c2740;border-radius:14px;padding:18px;box-shadow:0 10px 25px rgba(0,0,0,.25)}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  textarea{width:100%;min-height:160px;background:#0d1527;color:var(--text);border:1px solid #1b2550;border-radius:12px;padding:12px;resize:vertical}
  .btn{cursor:pointer;border:1px solid #2a3570;background:#162044;color:#eaf3ff;border-radius:12px;padding:10px 14px}
  .btn:hover{background:#1a284f}
  .btn.primary{background-image:linear-gradient(135deg,var(--accent),#4cc9f0);border-color:transparent;color:white}
  .muted{color:var(--muted);font-size:14px}
  .toolbar{display:flex;gap:10px;margin-top:12px;flex-wrap:wrap}
  .switch{display:flex;align-items:center;gap:6px}
  input[type="text"],input[type="email"]{background:#0d1527;color:var(--text);border:1px solid #1b2550;border-radius:10px;padding:8px 10px}
  .hidden{display:none}
  .pill{font-size:12px;border:1px solid #2b386e;padding:2px 8px;border-radius:999px;color:#c9d6ff}
  .q{padding:14px;border:1px solid #21305f;border-radius:12px;margin:10px 0;background:#0e1730}
  .q h3{margin:0 0 8px 0;font-size:16px}
  .opt{display:block;margin:6px 0;padding:8px;border:1px solid #223264;border-radius:10px;background:#0c1530}
  .correct{border-color:#1e8b4d;background:#0d1f16}
  .explain{margin-top:6px;color:#b9c6ff;font-size:14px}
  .hr{height:1px;background:#1b254b;margin:16px 0}
  .sticky-footer{position:sticky;bottom:0;background:linear-gradient(180deg,rgba(11,18,32,0),var(--bg) 30%);padding-top:8px}
</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="dot"></div>
      <h1>Smart Exam Pro</h1>
      <span class="pill">Corrections</span>
      <span class="pill">üåó</span>
    </div>

    <!-- CREATE EXAM -->
    <div class="card">
      <h2 style="margin-top:0">Create Your Exam</h2>
      <p class="muted">Paste MCQs (any number of options A‚ÄìZ). Answers can be <code>Answer: B</code> or <code>Answer: D & E</code>. Optional <code>Explanation:</code> line is supported. You can also import a <b>.docx</b>, <b>.txt</b>, or <b>.md</b> file.</p>

      <div id="example" class="card" style="background:#0d1527;border-color:#1b2550;margin:10px 0 16px 0">
Q1: What does HTML stand for?
A) Hyperlinks and Text Markup Language
B) Hyper Text Markup Language
C) Home Tool Markup Language
D) Hyperlinking Textual Management Language
Answer: B
Explanation: HTML stands for Hyper Text Markup Language, used to structure web pages.
      </div>

      <textarea id="mcqArea" placeholder="Paste your MCQs or use Import‚Ä¶"></textarea>

      <div class="toolbar">
        <label class="btn">
          Import From File
          <input id="fileInput" type="file" accept=".docx,.txt,.md,.rtf" style="display:none">
        </label>
        <button id="genBtn" class="btn primary">Generate Exam</button>
        <button id="clearBtn" class="btn">Clear</button>
        <span class="muted" id="status"></span>
      </div>
    </div>

    <!-- RENDERED EXAM -->
    <div id="examCard" class="card hidden" style="margin-top:16px">
      <h2 style="margin-top:0">Exam Preview</h2>
      <div id="exam"></div>

      <div class="sticky-footer">
        <div class="hr"></div>
        <div class="toolbar">
          <button id="downloadJson" class="btn">Download JSON</button>
          <button id="backBtn" class="btn">Back</button>
          <span class="muted" id="count"></span>
        </div>
      </div>
    </div>
  </div>

<!-- Mammoth for .docx ‚Üí text -->
<script src="https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js"></script>
<script>
const mcqArea = document.getElementById('mcqArea');
const statusEl = document.getElementById('status');
const examCard = document.getElementById('examCard');
const examEl = document.getElementById('exam');
const countEl = document.getElementById('count');

document.getElementById('clearBtn').onclick = () => { mcqArea.value = ''; status(''); };
document.getElementById('backBtn').onclick = () => { examCard.classList.add('hidden'); window.scrollTo({top:0,behavior:'smooth'}); };
document.getElementById('downloadJson').onclick = () => {
  const set = parseMCQs(mcqArea.value);
  download('exam.json', JSON.stringify(set, null, 2));
};

document.getElementById('genBtn').onclick = () => {
  const set = parseMCQs(mcqArea.value);
  if (!set.questions.length) {
    alert("Couldn't find well-formed questions. Keep the pattern:\n\nQ1: Stem\nA) option\nB) option\n...\nAnswer: B or Answer: D & E\nExplanation: ... (optional)");
    return;
  }
  renderExam(set);
  examCard.classList.remove('hidden');
  window.scrollTo({top:examCard.offsetTop - 12, behavior:'smooth'});
};

document.getElementById('fileInput').addEventListener('change', handleFile);

/* ---- FILE IMPORT (DOCX/TXT/MD/RTF) ---- */
async function handleFile(ev){
  const f = ev.target.files[0];
  if(!f) return;
  status('Importing‚Ä¶');

  try{
    let text = '';
    if (f.name.toLowerCase().endsWith('.docx')) {
      const arrayBuffer = await f.arrayBuffer();
      const res = await window.mammoth.convertToHtml({arrayBuffer});
      // Get plain text while preserving newlines between blocks
      const html = res.value
        .replace(/<\/p>/g,'</p>\n')
        .replace(/<br\s*\/?>/g,'\n')
        .replace(/<\/h\d>/g,'\n');
      text = stripHtml(html);
    } else {
      text = await f.text();
    }

    // Normalize bullets like ‚ÄúA )‚Äù, ‚ÄúA.‚Äù, ‚Äú(A)‚Äù, ‚ÄúA - ‚Äù, etc. ‚Üí ‚ÄúA) ‚Äù
    text = normalizeChoices(text);

    mcqArea.value = text.trim() + '\n';
    const preview = parseMCQs(text);
    if (!preview.questions.length) {
      alert(`${location.host} says\n\nImported, but could not find well-formed questions. You can still edit in the textarea.`);
    } else {
      alert(`${location.host} says\n\nImported ${preview.questions.length} questions ‚úî`);
    }
    status('');
  }catch(err){
    console.error(err);
    alert('Import failed: ' + err.message);
    status('Import failed.');
  }finally{
    ev.target.value = '';
  }
}

function stripHtml(html){
  const tmp = document.createElement('div');
  tmp.innerHTML = html;
  const text = tmp.textContent || tmp.innerText || '';
  // Collapse multiple blank lines
  return text.replace(/\u00A0/g,' ')
             .replace(/\r/g,'')
             .replace(/[ \t]+\n/g,'\n')
             .replace(/\n{3,}/g,'\n\n');
}

function normalizeChoices(text){
  // Replace common bullets to a canonical "A) "
  // Examples handled: (A) , A. , A - , A ‚Äî , A : , A „Äë, A„Äë, A„Äë, and stray unicode spaces
  return text
    .replace(/^\s*\((([A-Z]))\)\s+/gm, '$1) ')
    .replace(/^\s*([A-Z])[.\-‚Äì‚Äî:]\s+/gm, '$1) ')
    .replace(/^\s*([A-Z])\s*[)\]]\s+/gm, '$1) ')
    .replace(/^\s*([A-Z])\s+[‚Äì‚Äî-]\s+/gm, '$1) ');
}

/* ---- MCQ PARSER (lenient, supports your file) ---- */
function parseMCQs(raw){
  // Unify line endings / trim right spaces
  let text = raw.replace(/\r/g,'').replace(/[ \t]+\n/g,'\n');

  // Some DOCX exports merge lines awkwardly; guard with a newline after "Answer:" or "Explanation:"
  text = text.replace(/(Answer\s*:.*?)(?=\n[A-Z]\))/g, '$1\n')
             .replace(/(Explanation\s*:.*?)(?=\nQ\d+\s*:|$)/g, '$1\n');

  // Split on Qn: headings. Keep the Q number using a capturing group.
  const blocks = text.split(/\n?(?=Q\s*\d+\s*:)/i);

  const questions = [];
  for (const blk of blocks) {
    const mQ = blk.match(/^Q\s*(\d+)\s*:\s*([\s\S]+)$/i);
    if (!mQ) continue;

    let body = mQ[2].trim();

    // Pull out Answer and Explanation (optional)
    let answerRaw = '';
    let explanation = '';

    // Explanation can be on same line or subsequent lines until next Q or EOF
    const expMatch = body.match(/Explanation\s*:\s*([\s\S]*?)$/i);
    if (expMatch) {
      explanation = expMatch[1].trim();
      body = body.slice(0, expMatch.index).trim();
    }

    // Answer can appear before or after Explanation
    const ansMatch = body.match(/Answer\s*:\s*([A-Z](?:\s*&\s*[A-Z]|(?:\s*[,/]\s*[A-Z]))*)/i);
    if (ansMatch) {
      answerRaw = ansMatch[1].toUpperCase();
      body = body.replace(ansMatch[0], '').trim();
    }

    // Collect options A) ‚Ä¶ Z) lines (allow multi-line options)
    // We‚Äôll split on lines that *start* with X) and keep text until the next option or end.
    const optRegex = /^([A-Z])\)\s*(.*)$/gm;
    const opts = [];
    let lastIndex = 0, match;
    const lines = body.split('\n');

    // Find all indices where a choice begins
    const starts = [];
    for (let i=0;i<lines.length;i++){
      const mm = lines[i].match(/^([A-Z])\)\s*(.*)$/);
      if (mm) starts.push(i);
    }
    // If no explicit A)/B) found, try fallback ‚ÄúA ‚Äù (bare letter + space) form
    if (!starts.length){
      for (let i=0;i<lines.length;i++){
        const mm = lines[i].match(/^([A-Z])\s{2,}(.*)$/);
        if (mm) starts.push(i);
      }
    }

    // Stem is everything before first option start
    const firstStart = starts.length ? starts[0] : lines.length;
    const stem = lines.slice(0, firstStart).join('\n').trim();

    // Build options by slicing between start indices
    for (let k=0;k<starts.length;k++){
      const start = starts[k];
      const end = (k+1<starts.length) ? starts[k+1] : lines.length;
      const firstLine = lines[start];
      const tag = (firstLine.match(/^([A-Z])/) || [,''])[1];
      const textChunk = [firstLine.replace(/^[A-Z]\)\s*/,'').trim()]
        .concat(lines.slice(start+1,end)).join('\n').trim();
      if (tag) opts.push({ tag, text: textChunk });
    }

    // If options still empty, skip this block
    if (!opts.length) continue;

    // Parse answers into array of letters
    let answers = [];
    if (answerRaw){
      answers = answerRaw
        .split(/[,/&]/).map(s=>s.trim()).filter(Boolean);
      // Also handle ‚ÄúD & E‚Äù joined by ampersand with spaces
      answers = answers.flatMap(s => s.split(/\s*&\s*/));
      answers = [...new Set(answers.map(s=>s.replace(/[^A-Z]/g,'')))].filter(Boolean);
      // Sanity: keep only those that exist as options
      const valid = new Set(opts.map(o=>o.tag));
      answers = answers.filter(a => valid.has(a));
    }

    questions.push({ number: +mQ[1], stem, options: opts, answers, explanation });
  }

  // Sort by detected number, then re-index
  questions.sort((a,b)=>a.number-b.number);
  return { questions };
}

/* ---- RENDER ---- */
function renderExam(set){
  examEl.innerHTML = '';
  let n = 0;
  for (const q of set.questions){
    n++;
    const wrap = document.createElement('div');
    wrap.className = 'q';
    const h = document.createElement('h3');
    h.textContent = `Q${n}: ${q.stem}`;
    wrap.appendChild(h);

    const correct = new Set(q.answers);
    for (const opt of q.options){
      const div = document.createElement('label');
      div.className = 'opt' + (correct.has(opt.tag) ? ' correct':'');
      div.innerHTML = `<strong>${opt.tag})</strong> ${escapeHtml(opt.text)}`;
      wrap.appendChild(div);
    }
    if (q.explanation){
      const ex = document.createElement('div');
      ex.className = 'explain';
      ex.textContent = 'Explanation: ' + q.explanation;
      wrap.appendChild(ex);
    }
    examEl.appendChild(wrap);
  }
  countEl.textContent = `${set.questions.length} questions parsed`;
}

/* ---- UTIL ---- */
function status(msg){ statusEl.textContent = msg; }
function download(name, data){
  const blob = new Blob([data], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = name; a.click();
  URL.revokeObjectURL(url);
}
function escapeHtml(s){ return s.replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }
</script>
</body>
</html>
