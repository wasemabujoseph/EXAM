<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Smart Exam Pro (Single-File Build)</title>
<style>
:root{
  --bg:#f5f7fb; --card:#fff; --text:#222; --muted:#6b7280;
  --primary:#3b82f6; --primary-600:#2563eb; --accent:#10b981; --danger:#ef4444;
  --ring-bg:#e5e7eb; --radius:14px; --shadow:0 8px 24px rgba(0,0,0,.08); --transition:.25s ease;
}
:root.dark{
  --bg:#0f172a; --card:#111827; --text:#e5e7eb; --muted:#9ca3af;
  --primary:#60a5fa; --primary-600:#3b82f6; --accent:#34d399; --danger:#f87171; --ring-bg:#1f2937; --shadow:0 10px 28px rgba(0,0,0,.45);
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text);display:flex;flex-direction:column}
.navbar{display:flex;align-items:center;justify-content:space-between;padding:14px 20px;position:sticky;top:0;background:linear-gradient(180deg,rgba(255,255,255,.9),rgba(255,255,255,.75));backdrop-filter:blur(6px);border-bottom:1px solid rgba(0,0,0,.06)}
:root.dark .navbar{background:linear-gradient(180deg,rgba(17,24,39,.9),rgba(17,24,39,.75));border-bottom:1px solid rgba(255,255,255,.06)}
.brand{display:flex;gap:10px;align-items:center;font-weight:700}
.logo-dot{width:12px;height:12px;border-radius:50%;background:var(--primary);box-shadow:0 0 0 4px rgba(59,130,246,.25)}
.icon-btn{background:transparent;border:1px solid rgba(0,0,0,.1);padding:8px 10px;border-radius:10px;cursor:pointer}
:root.dark .icon-btn{border-color:rgba(255,255,255,.15)}
.icon-btn:hover{transform:translateY(-1px)}
.checkbox{display:flex;align-items:center;gap:8px;cursor:pointer}
.checkbox.sm{font-size:12px;opacity:.85}
.main{max-width:980px;margin:32px auto;width:92%;flex:1}
.card{background:var(--card);border-radius:var(--radius);box-shadow:var(--shadow);padding:24px;margin-bottom:24px}
h2{margin-top:0}
.muted{color:var(--muted)}
.grid{display:grid;gap:16px;grid-template-columns:1fr 1fr;margin:12px 0 8px}
@media (max-width:720px){ .grid{grid-template-columns:1fr} }
input[type="text"], textarea{
  width:100%; padding:12px 14px; border-radius:12px; border:1px solid rgba(0,0,0,.12); background:transparent; color:var(--text);
}
:root.dark input[type="text"], :root.dark textarea{border-color:rgba(255,255,255,.15)}
textarea{min-height:240px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace}
.row{display:flex;align-items:center;gap:10px;margin-top:8px}
.req{color:var(--danger)}
.primary-btn,.secondary-btn{border:none;cursor:pointer;border-radius:12px;padding:12px 16px;font-weight:600;transition:var(--transition)}
.primary-btn{background:var(--primary);color:#fff}
.primary-btn:hover{background:var(--primary-600);transform:translateY(-1px)}
.secondary-btn{background:transparent;color:var(--primary);border:2px solid var(--primary)}
.secondary-btn:hover{background:var(--primary);color:#fff}
.format-example{background:linear-gradient(135deg,rgba(59,130,246,.10),rgba(16,185,129,.08));padding:12px;border-radius:12px;border:1px dashed rgba(0,0,0,.15);overflow:auto}
:root.dark .format-example{border-color:rgba(255,255,255,.18)}
.hidden{display:none}
.question{margin-bottom:16px;padding:14px;border-radius:12px;border:1px solid rgba(0,0,0,.06);background:rgba(0,0,0,.02)}
:root.dark .question{border-color:rgba(255,255,255,.08);background:rgba(255,255,255,.03)}
.opt{display:flex;gap:10px;padding:8px;border-radius:10px;cursor:pointer;align-items:flex-start}
label.opt:hover{background:rgba(59,130,246,.08)}
:root.dark label.opt:hover{background:rgba(96,165,250,.12)}
.choice-badge{min-width:24px;text-align:center;font-weight:700}
.option-text{white-space:pre-wrap}
.progress-bar{width:160px;height:10px;background:var(--ring-bg);border-radius:10px;overflow:hidden}
.progress-fill{height:100%;width:0;background:var(--accent);transition:width .3s ease}
.actions-row{display:flex;gap:12px;flex-wrap:wrap}
.result-top{display:flex;gap:24px;align-items:center;flex-wrap:wrap}
.kv{display:flex;gap:10px;align-items:center;font-size:15px}.kv span{color:var(--muted)}
.ring{width:120px;height:120px;border-radius:50%;background:conic-gradient(var(--accent) 0deg,var(--ring-bg) 0deg);display:grid;place-items:center}
.ring-inner{width:88px;height:88px;border-radius:50%;background:var(--card);display:grid;place-items:center}
#score-percent{font-weight:800;font-size:22px}
.result-correct{color:var(--accent);font-weight:700}
.result-wrong{color:var(--danger);font-weight:700}
.choice-line{display:flex;gap:8px;align-items:flex-start;margin:2px 0}
.choice-mark{font-weight:700}
.choice-mark.correct{color:var(--accent)}
.choice-mark.wrong{color:var(--danger)}
.footer{text-align:center;color:var(--muted);padding:18px 10px;border-top:1px solid rgba(0,0,0,.06)}
:root.dark .footer{border-top-color:rgba(255,255,255,.08)}
.fade-in{animation:fade .4s ease}
@keyframes fade{from{opacity:.0;transform:translateY(6px)} to{opacity:1;transform:none}}
@media print {
  body{background:#fff;color:#000}
  .navbar,.footer,.primary-btn,.secondary-btn,.icon-btn,.progress-bar{display:none!important}
  .card{box-shadow:none;border:0;margin:0;padding:0}
  .question{page-break-inside:avoid}
}
</style>
</head>
<body>
<header class="navbar">
  <div class="brand">
    <div class="logo-dot" aria-hidden="true"></div>
    <span>Smart Exam Pro</span>
  </div>
  <div class="actions">
    <input id="file-input" type="file" accept=".txt,.doc,.docx,.pdf,.sep,.json" hidden />
    <button id="import-btn" class="icon-btn" title="Import MCQs" type="button" aria-label="Import">üì•</button>
    <button id="export-all-pdf-btn" class="icon-btn" title="Export results (all)" type="button" aria-label="Export all">üñ®Ô∏è</button>
    <button id="export-wrong-pdf-btn" class="icon-btn" title="Export wrong-only" type="button" aria-label="Export wrong only">üßæ</button>
    <label class="checkbox sm" title="Show corrections in export">
      <input id="export-corrections" type="checkbox" checked />
      <span>Corrections</span>
    </label>
    <button id="theme-toggle" class="icon-btn" title="Toggle theme" type="button" aria-label="Toggle theme">üåó</button>
  </div>
</header>

<main class="main">
  <!-- Student Info -->
  <section id="student-section" class="card fade-in">
    <h2>üë§ Student Information</h2>
    <p class="muted">Please enter your details to begin.</p>

    <form id="student-form" autocomplete="on">
      <div class="grid">
        <label>Full Name <span class="req">*</span>
          <input id="student-name" name="student-name" type="text" placeholder="e.g., Waseem Khallaf" required />
        </label>
        <label>Email / ID (optional)
          <input id="student-id" name="student-id" type="text" placeholder="e.g., waseem@example.com or 2025-0012" />
        </label>
      </div>
      <div class="row">
        <label class="checkbox">
          <input id="save-locally" type="checkbox" checked />
          <span>Remember my name and theme on this device</span>
        </label>
      </div>
      <button class="primary-btn" type="submit">Continue</button>
    </form>
  </section>

  <!-- Input -->
  <section id="input-section" class="card hidden fade-in">
    <h2>üìÑCreate Your Exam</h2>
    <p>Paste MCQs (any number of options A‚ÄìZ). Answers can be <code>Answer: B</code> or <code>Answer: D &amp; E</code>.</p>
    <pre class="format-example">
Q1: What does HTML stand for?
A) Hyperlinks and Text Markup Language
B) Hyper Text Markup Language
C) Home Tool Markup Language
D) Hyperlinking Textual Management Language
Answer: B
Explanation: HTML stands for Hyper Text Markup Language, used to structure web pages.
    </pre>
    <textarea id="mcq-input" placeholder="Paste your MCQs or use üì• Import..."></textarea>
    <div class="row">
      <button id="generate-btn" class="primary-btn" type="button">Generate Exam</button>
      <button id="import-here-btn" class="secondary-btn" type="button">Import From File</button>
    </div>
  </section>

  <!-- Exam -->
  <section id="exam-section" class="card hidden fade-in">
    <div class="exam-header">
      <div>
        <h2>üìÉ Exam for <span id="student-name-live"></span></h2>
        <p class="muted">Select one answer for each question.</p>
      </div>
      <div class="progress-bar" aria-label="Progress">
        <div id="progress-fill" class="progress-fill"></div>
      </div>
    </div>
    <form id="exam-form"></form>
    <div class="actions-row">
      <button id="submit-btn" class="primary-btn" type="button">Submit Answers</button>
      <button id="cancel-btn" class="secondary-btn" type="button">Back</button>
    </div>
  </section>

  <!-- Results -->
  <section id="result-section" class="card hidden fade-in">
    <h2>üìù Exam Results</h2>
    <div class="result-top">
      <div class="ring" id="score-ring">
        <div class="ring-inner">
          <div id="score-percent">0%</div>
        </div>
      </div>
      <div class="result-meta">
        <div class="kv"><span>Student:</span><strong id="student-name-result"></strong></div>
        <div class="kv"><span>Questions:</span><strong id="q-count"></strong></div>
        <div class="kv"><span>Correct:</span><strong id="q-correct"></strong></div>
        <div class="kv"><span>Wrong:</span><strong id="q-wrong"></strong></div>
      </div>
    </div>
    <hr/>
    <div id="analysis"></div>
    <div class="actions-row">
      <button id="retest-wrong-btn" class="primary-btn" type="button">Retest Wrong Only</button>
      <button id="retry-btn" class="secondary-btn" type="button">Retry Full Exam</button>
      <button id="back-btn" class="secondary-btn" type="button">Create New Exam</button>
    </div>
  </section>
</main>

<footer class="footer">
  <p>üìÉ <span id="year"></span> Smart Exam Pro üìÑ Built for learning</p>
</footer>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const els = {
    studentSection: document.getElementById("student-section"),
    inputSection: document.getElementById("input-section"),
    examSection: document.getElementById("exam-section"),
    resultSection: document.getElementById("result-section"),
    studentForm: document.getElementById("student-form"),
    studentName: document.getElementById("student-name"),
    studentId: document.getElementById("student-id"),
    saveLocally: document.getElementById("save-locally"),
    mcqInput: document.getElementById("mcq-input"),
    generateBtn: document.getElementById("generate-btn"),
    importHereBtn: document.getElementById("import-here-btn"),
    examForm: document.getElementById("exam-form"),
    submitBtn: document.getElementById("submit-btn"),
    cancelBtn: document.getElementById("cancel-btn"),
    progressFill: document.getElementById("progress-fill"),
    studentNameLive: document.getElementById("student-name-live"),
    retryBtn: document.getElementById("retry-btn"),
    backBtn: document.getElementById("back-btn"),
    retestWrongBtn: document.getElementById("retest-wrong-btn"),
    scoreRing: document.getElementById("score-ring"),
    scorePercent: document.getElementById("score-percent"),
    studentNameResult: document.getElementById("student-name-result"),
    qCount: document.getElementById("q-count"),
    qCorrect: document.getElementById("q-correct"),
    qWrong: document.getElementById("q-wrong"),
    analysis: document.getElementById("analysis"),
    themeToggle: document.getElementById("theme-toggle"),
    fileInput: document.getElementById("file-input"),
    importBtn: document.getElementById("import-btn"),
    exportAllPdfBtn: document.getElementById("export-all-pdf-btn"),
    exportWrongPdfBtn: document.getElementById("export-wrong-pdf-btn"),
    exportCorrections: document.getElementById("export-corrections"),
  };

  const yearEl = document.getElementById("year");
  if (yearEl) yearEl.textContent = new Date().getFullYear();

  const savedTheme = localStorage.getItem("sep-theme");
  if (savedTheme === "dark") document.documentElement.classList.add("dark");
  els.themeToggle?.addEventListener("click", () => {
    document.documentElement.classList.toggle("dark");
    localStorage.setItem("sep-theme", document.documentElement.classList.contains("dark") ? "dark" : "light");
  });

  // preload student
  try {
    const saved = JSON.parse(localStorage.getItem("sep-student") || "{}");
    if (saved.name) els.studentName.value = saved.name;
    if (saved.id) els.studentId.value = saved.id;
  } catch {}

  let mcqData = [];
  let lastResults = null;

  // student submit -> move to input
  els.studentForm?.addEventListener("submit", (e) => {
    e.preventDefault();
    const name = els.studentName.value.trim();
    if (!name) { alert("Please enter your full name."); return; }
    if (els.saveLocally.checked) {
      localStorage.setItem("sep-student", JSON.stringify({ name, id: els.studentId.value.trim() }));
    } else {
      localStorage.removeItem("sep-student");
    }
    toggle(els.studentSection, false);
    toggle(els.inputSection, true);
  });

  // import triggers
  els.importBtn?.addEventListener("click", () => els.fileInput.click());
  els.importHereBtn?.addEventListener("click", () => els.fileInput.click());
  els.fileInput?.addEventListener("change", handleImport);

  // generate
  els.generateBtn?.addEventListener("click", () => {
    const src = els.mcqInput.value.trim();
    if (!src) { alert("Paste your MCQs first or import from file."); return; }
    mcqData = parseMCQs(src);
    if (!mcqData.length) { alert("Could not parse MCQs. Please check the format."); return; }
    renderExam(mcqData);
    els.studentNameLive.textContent = els.studentName.value.trim() || "Student";
    updateProgress(0);
    toggle(els.inputSection, false);
    toggle(els.examSection, true);
  });

  // cancel back to input
  els.cancelBtn?.addEventListener("click", () => {
    toggle(els.examSection, false);
    toggle(els.inputSection, true);
  });

  // submit exam
  els.submitBtn?.addEventListener("click", () => {
    if (!mcqData.length) { alert("No exam loaded."); return; }
    const results = [];
    let correct = 0;

    mcqData.forEach((q, i) => {
      const selected = document.querySelector(`input[name="q${i}"]:checked`);
      const ans = selected ? selected.value : null;
      const isCorrect = ans ? q.answer.includes(ans) : false;
      if (isCorrect) correct++;
      results.push({ ...q, selected: ans, isCorrect });
    });

    lastResults = results;
    const percent = Math.round((correct / mcqData.length) * 100);
    showResults(results, percent);
  });

  // retry
  els.retryBtn?.addEventListener("click", () => {
    document.querySelectorAll("input[type=radio]").forEach(r => (r.checked = false));
    updateProgress(0);
    toggle(els.resultSection, false);
    toggle(els.examSection, true);
  });

  // retest wrong
  els.retestWrongBtn?.addEventListener("click", () => {
    if (!lastResults) { alert("No previous results found."); return; }
    const wrongQs = lastResults.filter(r => !r.isCorrect);
    if (!wrongQs.length) { alert("Great job! No wrong answers to retest."); return; }
    mcqData = wrongQs.map(r => ({
      question: r.question,
      options: r.options.slice(),
      answer: r.answer.slice(),
      explanation: r.explanation || ""
    }));
    renderExam(mcqData);
    els.studentNameLive.textContent = els.studentName.value.trim() || "Student";
    updateProgress(0);
    toggle(els.resultSection, false);
    toggle(els.examSection, true);
  });

  // back to new exam
  els.backBtn?.addEventListener("click", () => {
    toggle(els.resultSection, false);
    toggle(els.inputSection, true);
  });

  // exports
  els.exportAllPdfBtn?.addEventListener("click", () => exportResults({ wrongOnly: false, withCorrections: els.exportCorrections.checked }));
  els.exportWrongPdfBtn?.addEventListener("click", () => exportResults({ wrongOnly: true, withCorrections: els.exportCorrections.checked }));

  function toggle(el, show) { if (!el) return; el.classList[show ? "remove" : "add"]("hidden"); }
  function updateProgress(val) { if (els.progressFill) els.progressFill.style.width = `${val}%`; }

  function renderExam(questions) {
    els.examForm.innerHTML = "";
    questions.forEach((q, i) => {
      const wrap = document.createElement("div");
      wrap.className = "question";

      const p = document.createElement("p");
      const strong = document.createElement("strong");
      strong.textContent = `Q${i + 1}: `;
      p.appendChild(strong);
      p.appendChild(document.createTextNode(q.question));
      wrap.appendChild(p);

      q.options.forEach(opt => {
        const letter = opt.label;
        const id = `q${i}_${letter}`;
        const label = document.createElement("label");
        label.className = "opt";
        label.setAttribute("for", id);

        const input = document.createElement("input");
        input.id = id;
        input.type = "radio";
        input.name = `q${i}`;
        input.value = letter;

        const spanLetter = document.createElement("span");
        spanLetter.className = "choice-badge";
        spanLetter.textContent = letter + ")";

        const spanText = document.createElement("span");
        spanText.className = "option-text";
        spanText.textContent = " " + opt.text;

        label.appendChild(input);
        label.appendChild(spanLetter);
        label.appendChild(spanText);
        wrap.appendChild(label);
      });

      els.examForm.appendChild(wrap);
    });

    const onChange = () => {
      const total = questions.length;
      const answered = Array.from(els.examForm.querySelectorAll("input[type=radio]:checked"))
        .map(r => r.name).filter((v, i, arr) => arr.indexOf(v) === i).length;
      updateProgress(Math.round(answered / total * 100));
    };
    els.examForm.addEventListener("change", onChange, { once:false });
  }

  function showResults(results, percent) {
    const deg = Math.round((percent / 100) * 360);
    els.scoreRing.style.background = `conic-gradient(var(--accent) ${deg}deg, var(--ring-bg) 0deg)`;
    els.scorePercent.textContent = `${percent}%`;

    els.studentNameResult.textContent = els.studentName.value.trim() || "Student";
    els.qCount.textContent = results.length;
    const correct = results.filter(r => r.isCorrect).length;
    els.qCorrect.textContent = correct;
    els.qWrong.textContent = results.length - correct;

    els.analysis.innerHTML = "";
    results.forEach((r, i) => {
      const block = document.createElement("div");
      block.className = "question";

      const qp = document.createElement("p");
      const strong = document.createElement("strong");
      strong.textContent = `Q${i + 1}: `;
      qp.appendChild(strong);
      qp.appendChild(document.createTextNode(r.question));
      block.appendChild(qp);

      r.options.forEach(opt => {
        const line = document.createElement("div");
        line.className = "choice-line";
        const badge = document.createElement("span");
        badge.className = "choice-badge";
        badge.textContent = opt.label + ")";

        const text = document.createElement("span");
        text.className = "option-text";
        text.textContent = opt.text;

        const mark = document.createElement("span");
        mark.className = "choice-mark";
        const isCorrectChoice = r.answer.includes(opt.label);
        const isSelected = r.selected === opt.label;
        if (isCorrectChoice && isSelected) {
          mark.classList.add("correct");
          mark.textContent = "  ‚úÖ (correct, selected)";
        } else if (isCorrectChoice) {
          mark.classList.add("correct");
          mark.textContent = "  ‚úÖ (correct)";
        } else if (isSelected) {
          mark.classList.add("wrong");
          mark.textContent = "  ‚ùå (your choice)";
        } else {
          mark.textContent = "";
        }

        line.appendChild(badge);
        line.appendChild(text);
        line.appendChild(mark);
        block.appendChild(line);
      });

      const ap = document.createElement("p");
      const ansLetters = r.answer.join(" & ");
      ap.appendChild(document.createTextNode(`Your Answer: ${r.selected || "None"}  |  Correct Answer: ${ansLetters}`));
      ap.appendChild(document.createElement("br"));
      const ansSpan = document.createElement("span");
      ansSpan.className = r.isCorrect ? "result-correct" : "result-wrong";
      ansSpan.textContent = r.isCorrect ? " ‚úî Correct" : " ‚úò Wrong";
      ap.appendChild(ansSpan);
      block.appendChild(ap);

      if (r.explanation) {
        const ep = document.createElement("p");
        const eStrong = document.createElement("strong");
        eStrong.textContent = "Explanation: ";
        ep.appendChild(eStrong);
        ep.appendChild(document.createTextNode(r.explanation));
        block.appendChild(ep);
      }

      els.analysis.appendChild(block);
    });

    toggle(els.examSection, false);
    toggle(els.resultSection, true);
  }

  async function handleImport(ev) {
    const file = ev.target.files && ev.target.files[0];
    if (!file) return;

    try {
      const ext = (file.name.split(".").pop() || "").toLowerCase();
      let text = "";

      if (ext === "txt" || ext === "sep" || ext === "json") {
        text = await file.text();
      } else if (ext === "pdf") {
        try {
          text = await file.text();
        } catch {
          alert("Direct PDF text extraction isn‚Äôt supported in-browser. Export the PDF to .txt and import again.");
          return;
        }
      } else if (ext === "docx" || ext === "doc") {
        try {
          text = await file.text();
        } catch {
          alert("Direct DOC/DOCX parsing is limited in-browser. Save as .txt and re-import.");
          return;
        }
      } else {
        alert("Unsupported file type. Use .txt, .docx, .pdf (text-based), or .sep export.");
        return;
      }

      const extracted = extractSepBlock(text);
      if (extracted) text = extracted;

      els.mcqInput.value = text;

      const parsed = parseMCQs(text);
      if (!parsed.length) {
        alert("Imported, but could not find well-formed questions. You can still edit in the textarea.");
        // stay on input page
        toggle(els.studentSection, false);
        toggle(els.inputSection, true);
        return;
      }

      // Go directly to exam after import
      mcqData = parsed;
      renderExam(mcqData);
      els.studentNameLive.textContent = els.studentName.value.trim() || "Student";
      updateProgress(0);
      toggle(els.studentSection, false);
      toggle(els.inputSection, false);
      toggle(els.examSection, true);
    } finally {
      els.fileInput.value = "";
    }
  }

  function exportResults({ wrongOnly, withCorrections }) {
    if (!lastResults) { alert("No results to export yet."); return; }
    const results = wrongOnly ? lastResults.filter(r => !r.isCorrect) : lastResults.slice();
    if (!results.length) { alert("Nothing to export for the chosen settings."); return; }

    const wnd = window.open("", "_blank");
    const title = wrongOnly ? "Smart Exam Pro ‚Äî Wrong Only" : "Smart Exam Pro ‚Äî Full Results";
    const student = els.studentName.value.trim() || "Student";
    const now = new Date().toLocaleString();

    const payload = makeSepBlockFromResults(results);
    const css = `
      <style>
        body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;padding:24px; color:#111}
        h1{margin:0 0 6px 0}
        .muted{color:#555}
        .q{margin:14px 0; border:1px solid #ddd; padding:10px; border-radius:10px}
        .choice{display:flex;gap:8px;align-items:flex-start}
        .badge{min-width:24px;text-align:center;font-weight:700}
        .ok{color:#0a7d51;font-weight:700}
        .bad{color:#b00020;font-weight:700}
        .small{font-size:12px;color:#666}
        pre{white-space:pre-wrap; word-wrap:break-word; font-family:ui-monospace,Menlo,Consolas,monospace; background:#fafafa; border:1px dashed #ddd; padding:10px; border-radius:10px}
        @media print {.noprint{display:none}}
      </style>`;

    const bodyTop = `
      <h1>${title}</h1>
      <div class="muted">Student: <b>${escapeHtml(student)}</b> &nbsp;|&nbsp; Generated: ${escapeHtml(now)}</div>
      <hr/>`;

    const parts = results.map((r, idx) => {
      const ansLetters = r.answer.join(" & ");
      const lines = r.options.map(opt => {
        const isCorrect = r.answer.includes(opt.label);
        const isSelected = r.selected === opt.label;
        let tail = "";
        if (withCorrections) {
          if (isCorrect && isSelected) tail = ` <span class="ok">‚úÖ correct, selected</span>`;
          else if (isCorrect) tail = ` <span class="ok">‚úÖ correct</span>`;
          else if (isSelected) tail = ` <span class="bad">‚ùå your choice</span>`;
        }
        return `<div class="choice"><span class="badge">${opt.label})</span><span>${escapeHtml(opt.text)}${tail}</span></div>`;
      }).join("");

      const exp = r.explanation ? `<div class="small"><b>Explanation:</b> ${escapeHtml(r.explanation)}</div>` : "";
      return `<div class="q">
        <div><b>Q${idx + 1}:</b> ${escapeHtml(r.question)}</div>
        ${lines}
        <div class="small"><b>Your answer:</b> ${escapeHtml(r.selected || "None")} &nbsp; | &nbsp; <b>Correct:</b> ${escapeHtml(ansLetters)}</div>
        ${exp}
      </div>`;
    }).join("");

    const body = `${bodyTop}${parts}<hr/><div class="small">Below is an embedded block Smart Exam Pro can re-import:</div><pre>${escapeHtml(payload)}</pre><div class="noprint"><em>Use your browser‚Äôs ‚ÄúSave as PDF‚Äù.</em></div>`;

    wnd.document.write(`<!doctype html><html><head><meta charset="utf-8"/><title>${title}</title>${css}</head><body>${body}</body></html>`);
    wnd.document.close();
  }

  // ---------- Parsing ----------
  function parseMCQs(text) {
    const lines = text.split(/\r?\n/).map(l => l.replace(/\s+$/, ""));
    const qs = [];
    let cur = emptyQ();

    const qHead = /^Q\s*(\d+)\s*:\s*(.*)$/i;
    const optHead = /^([A-Z])(?:\s*[\)\.\:])\s*(.*)$/;
    const answerHead = /^Answer\s*:\s*(.+)$/i;
    const explHead = /^Explanation\s*:\s*(.*)$/i;

    const pushCur = () => {
      if (cur.question) {
        cur.options = normalizeOptions(cur.options);
        cur.answer = normalizeAnswers(cur.answerRaw, cur.options);
        if (cur.options.length && cur.answer.length) {
          qs.push({
            question: cur.question.trim(),
            options: cur.options,
            answer: cur.answer,
            explanation: (cur.explanation || "").trim()
          });
        }
      }
    };

    let collectingOption = null;

    for (let i = 0; i < lines.length; i++) {
      const raw = lines[i];
      const line = raw.trim();
      if (!line) {
        if (collectingOption) collectingOption.text += "\n";
        else if (cur.explanation) cur.explanation += "\n";
        continue;
      }

      const mQ = line.match(qHead);
      if (mQ) {
        if (collectingOption) { cur.options.push(collectingOption); collectingOption = null; }
        pushCur();
        cur = emptyQ();
        cur.question = mQ[2] || "";
        continue;
      }

      const mO = line.match(optHead);
      if (mO) {
        if (collectingOption) { cur.options.push(collectingOption); }
        collectingOption = { label: mO[1].toUpperCase(), text: mO[2] || "" };
        continue;
      }

      const mA = line.match(answerHead);
      if (mA) {
        if (collectingOption) { cur.options.push(collectingOption); collectingOption = null; }
        cur.answerRaw = (cur.answerRaw ? cur.answerRaw + " " : "") + mA[1];
        continue;
      }

      const mE = line.match(explHead);
      if (mE) {
        if (collectingOption) { cur.options.push(collectingOption); collectingOption = null; }
        cur.explanation = (mE[1] || "");
        continue;
      }

      if (collectingOption) {
        collectingOption.text += (collectingOption.text ? "\n" : "") + raw;
      } else if (cur.explanation) {
        cur.explanation += (cur.explanation ? " " : "") + raw;
      } else if (cur.question) {
        cur.question += " " + raw;
      }
    }
    if (collectingOption) { cur.options.push(collectingOption); collectingOption = null; }
    pushCur();

    return qs;
  }

  function emptyQ() { return { question: "", options: [], answerRaw: "", explanation: "" }; }

  function normalizeOptions(opts) {
    const map = new Map();
    opts.forEach(o => {
      const label = (o.label || "").toUpperCase();
      const text = (o.text || "").trim();
      if (!label || !/^[A-Z]$/.test(label)) return;
      if (!map.has(label)) map.set(label, text);
      else map.set(label, (map.get(label) + (text ? "\n" + text : "")).trim());
    });
    return Array.from(map.entries()).sort((a,b)=>a[0].localeCompare(b[0]))
      .map(([label,text]) => ({ label, text }));
  }

  function normalizeAnswers(raw, options) {
    const letters = new Set(options.map(o => o.label));
    const picks = String(raw || "")
      .replace(/and/gi, ",")
      .replace(/[;&+\/]/g, ",")
      .replace(/\s+/g, "")
      .split(",")
      .map(x => x.toUpperCase())
      .filter(x => /^[A-Z]$/.test(x) && letters.has(x));
    if (!picks.length && raw && /^[A-Za-z]/.test(raw)) {
      const c = raw[0].toUpperCase();
      if (letters.has(c)) picks.push(c);
    }
    return Array.from(new Set(picks));
  }

  function makeSepBlockFromResults(results) {
    const lines = [];
    results.forEach((r, idx) => {
      lines.push(`Q${idx + 1}: ${r.question}`);
      r.options.forEach(o => lines.push(`${o.label}) ${o.text}`));
      lines.push(`Answer: ${r.answer.join(" & ")}`);
      if (r.explanation) lines.push(`Explanation: ${r.explanation}`);
      lines.push("");
    });
    return ["###SEP-EXAM-BEGIN###", ...lines, "###SEP-EXAM-END###"].join("\n");
  }

  function extractSepBlock(text) {
    const s = text.indexOf("###SEP-EXAM-BEGIN###");
    const e = text.indexOf("###SEP-EXAM-END###");
    if (s !== -1 && e !== -1 && e > s) {
      return text.slice(s + "###SEP-EXAM-BEGIN###".length, e).trim();
    }
    return null;
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
  }
});
</script>
</body>
</html>
